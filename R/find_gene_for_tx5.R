# For each transcript, find the gene it comes from.
# Use the gtf generated by stringtie to get transcript coordinates,
# use the gtf from Wormbase to get gene coordinates.

# note this script to be run on cluster; number of cores in the wrapper (15)

cat("Starting\n\n")


library(AnnotationDbi)
library(GenomicFeatures)
library(tidyverse)
library(parallel)

library(wbData)
options(wb_dir_cache = "/gpfs/ycga/project/ysm/hammarlund/aw853/references/WS277/")



# Prepare both GTFs ----
cat("\n\nPreparing GTF files...\n\n")

wb_txdb <- wb_load_TxDb(277)
wb_exons <- exonsBy(wb_txdb, by = "gene")


sequ_txdb <- makeTxDbFromGFF("intermediates/210818_str2_outs/summaries/merged_corrected.gtf",
                             organism = "Caenorhabditis elegans",
                             dataSource = "WS277_collapsed_stringtie")
sequ_exons <- exonsBy(sequ_txdb, by = "gene")


# Find genes with intersection
# based on nb of exons and/or on length of intersection
equivalent_genes <- function(sequ_gr, ref_gr, thres_prop_exons = 1/3, thres_length = 1/3){
  n_ex_equal <- length(which(!is.na(findOverlaps(sequ_gr,
                                                 ref_gr,
                                                 type="equal",
                                                 select = "first"))))
  n_ex_tot <- length(sequ_gr)
  length_inter <- sum(width(intersect(sequ_gr,
                                      ref_gr)))
  length_tot <- sum(width(GenomicRanges::reduce(sequ_gr)))
  return((n_ex_equal/n_ex_tot > thres_prop_exons) || (length_inter/length_tot > thres_length))
}

# Notice: this function uses objects in the Global Environment
match_gene_name <- function(s_g){
  ol_genes <- findOverlaps(sequ_exons[s_g], wb_exons, type="any")
  length(ol_genes)

  if(length(ol_genes) == 1){
    if(equivalent_genes(sequ_exons[[s_g]], wb_exons[[to(ol_genes)]])){
      return(names(wb_exons[to(ol_genes)]))
    } else{
      return(paste0("UNG_", s_g))
    }
  } else if(length(ol_genes) > 1){
    equ_genes <- map_lgl(to(ol_genes), ~ equivalent_genes(sequ_exons[[s_g]],
                                                          wb_exons[[.x]]))
    if(sum(equ_genes) == 1){
      return(names(wb_exons[to(ol_genes)[equ_genes]]))
    } else if(sum(equ_genes) > 1){
      warning(paste0("Several genes could match. Returning first: ",
                     names(wb_exons[to(ol_genes)[equ_genes]])[1]))
      return(names(wb_exons[to(ol_genes)[equ_genes]])[1])
    } else{
      return(paste0("UNG_", s_g))
    }

  } else{
    return(paste0("UNG_", s_g))
  }
}


# # Some testing of the functions
# vcol <- RColorBrewer::brewer.pal(8, "Dark2")
# s_g <- 1
# ###################################
# s_g <- s_g + 1
# match_gene_name(s_g)
# plotRanges(sequ_exons[[s_g]])
# for(i in seq_along(to(findOverlaps(sequ_exons[s_g], wb_exons)))){
#   plotRanges(wb_exons[[to(findOverlaps(sequ_exons[s_g], wb_exons))[i]]],
#              add=TRUE, col=vcol[i], border=NA)
# }
# names(wb_exons[to(findOverlaps(sequ_exons[s_g], wb_exons))])

cat("\n\nRunning!\n")
tx_genes_wb_names <- as.character(mclapply(seq_along(sequ_exons), match_gene_name, mc.cores=15))
cat("\nDone\n")

# Find names for all genes
genes_tbl <- tibble(gene_sequ_name = names(sequ_exons),
                    gene_wb_name = tx_genes_wb_names)
transcripts_tbl <- AnnotationDbi::select(sequ_txdb,
                                         keys = keys(sequ_txdb, keytype = "TXNAME"),
                                         columns = c("TXNAME", "GENEID"),
                                         keytype = "TXNAME") %>%
  left_join(genes_tbl, by = c("GENEID" = "gene_sequ_name")) %>%
  select(feature_id = TXNAME,
         gene_id = gene_wb_name)



# was any of the non-directed novel transcripts attributed to an existing gene?
# (context: Stringtie produces some transcripts where it can't determine orientation,
# and indicates "." as strand. Using awk, these lines were written twice with r or f at the end of
# the transcript name. If none of these transcripts were attributed to a gene, we don't need to care
# about strand anymore)
# look at all novel transcripts
cat("Transcripts with r or f:\n")

table(! is.na(str_extract(transcripts_tbl$feature_id, pattern = ".*[rf]$")))/2

transcripts_tbl$feature_id[! is.na(str_extract(transcripts_tbl$feature_id, pattern = ".*r$"))] %>%
  str_extract(pattern = "UNG_") %>%
  is.na() %>%
  table()

transcripts_tbl$feature_id[! is.na(str_extract(transcripts_tbl$feature_id, pattern = ".*f$"))] %>%
  str_extract(pattern = "UNG_") %>%
  is.na() %>%
  table()


# if all adds up, eliminate "r" lines
transcripts_tbl <- transcripts_tbl[is.na(str_extract(transcripts_tbl$feature_id, pattern = ".*r$")),]
# remove trailing ".f"s
transcripts_tbl$feature_id <- str_replace(transcripts_tbl$feature_id, pattern = "\\.f$", replacement = "")




# Export ----

cat("Saving...")

saveRDS(transcripts_tbl, "intermediates/transcript_WBGene_lut.rds")
