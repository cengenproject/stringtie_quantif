# Select main transcript for each gene-neuron
# export for Deep Learning
#
# > run on HPC
# 
# Load "t_exp" generated by summarize_stringtie_q_output
# For each sample-gene, select main transcript (highest TPM)
# For each neuron, use majority vote across samples
# Use scRNA-Seq to filter gene-neuron that are expressed
# For each gene, make a table of transcripts describing segments as introns and exons
# Export a table with the main transcript for each gene-neuron, and tables for each gene


cat("Starting R script...\n")


## Inits ----
suppressPackageStartupMessages({
  library(tidyverse)
})

library(wbData)
options(wb_dir_cache = "/home/aw853/project/references/WS281")
gids <- wb_load_gene_ids(281)



# I/O storage
interm_dir <- "intermediates/intermediates_for_DL/220919/"
input_data <- "intermediates/220322_str_q_outs/summaries/t_exp.tsv"

# for testing on local PC
# input_data <- "data/220128_str_q_summaries/t_exp.tsv"


#~ functions ----

majority_vote <- function(x, tie_breaker){
  
  majority_vote <- which(x == max(x))
  
  if(length(majority_vote) == 0L){
    stop("Failed to take majority vote.")
  }
  
  if(length(majority_vote) == 1L){
    final_vote <- majority_vote
  } else{
    final_vote <- which(x == max(x) &
                          tie_breaker == max(tie_breaker[majority_vote]))
    
    if(length(final_vote) > 1L){
      warning("Tie for majority vote, taking a random winner.")
      final_vote <- sample(final_vote, 1)
    }
  }
  
  final_vote
}



#~ Load data ----

# transcript-sample quantifs
tx_long <- read_tsv(input_data,
                    col_types = cols(transcript_id = col_factor(),
                                     gene_id = col_factor(),
                                     sample_id = col_factor(),
                                     neuron_id = col_factor(),
                                     TPM = col_double()))

stop_for_problems(tx_long)

## Processing ----

#~ Select main transcript-neuron ----

# for testing on small dataset
# subsample_gene <- s2i(c("nlp-40", "C25H3.11"), gids)
# subsample_neur <- c("AIM", "ADL", "AVM")
# 
# subsample_gene <- sample(tx_long$gene_id, 100) |> unique()
# subsample_neur <- sample(tx_long$neuron_id, 10) |> unique()
# 
# tx_long2 <- filter(tx_long,
#                   neuron_id %in% subsample_neur,
#                   gene_id %in% subsample_gene)



cat("Processing.\n")

# get main tx per sample
#(note, nesting for performance, just grouping recomputes main_tx)
tx_sample <- tx_long |>
  mutate(transcript_id = as.character(transcript_id)) |>
  group_by(neuron_id, sample_id, gene_id) |>
  nest() |>
  mutate(main_tx = map_chr(data,
                           ~ .x[["transcript_id"]][which.max(.x[["TPM"]])]),
  tx_mean_TPM = map_dbl(data,
                               ~ mean(.x[["TPM"]][.x[["transcript_id"]] == main_tx]))) |>
  select(-data) 

qs::qsave(tx_sample,
          paste0(interm_dir,"tx_sample.qs"))

# collect votes per neuron type
cat("collecting votes per neuron type.\n")
collected_per_neur <- tx_sample |>
  group_by(gene_id, neuron_id, main_tx) |>
  summarize(nb_votes = n(),
            sum_voters = sum(tx_mean_TPM))

qs::qsave(collected_per_neur,
          paste0(interm_dir, "collected_per_neur.qs"))

# select single tx per neuron
cat("Selecting single tx per neuron.\n")
tx_neuron <- collected_per_neur |>
  group_by(gene_id, neuron_id) |>
  summarize(main_tx = main_tx[majority_vote(nb_votes,
                                            tie_breaker = sum_voters)])
qs::qsave(tx_neuron,
          paste0(interm_dir, "tx_neuron.qs"))

cat("Done.\n")












